#!ruby!
# One should be able to follow along using irb.
# The purpose of the code here is show math.
# It's not necessarily the actual code.
# What is Entropy?
# Here, basically it is (at random) one (string) of many possible:

  class Entropy < String
    attr_reader :base, :bits
    def initialize(entropy='', base=2)
      super(entropy)
      @base = base
      @bits = base ** self.length
    end

    def increase(n=1)
      n.times{self<<rand(@base).to_s}
      @bits = @base ** self.length
      self
    end
    alias pp increase

    def set_bits(b, z='0')
      @bits = b
      # Sometimes we need to pad entropy back up.
      while @bits > @base ** self.length
        self.insert(0, z)
      end
    end

    def self.[](n)
      Entropy.new.pp(n)
    end
  end

  # For concision:
  E = Entropy

# Because of the dual nature of split pad files,
# in the code I use the terms Yin and Yang.
# Yin refers to the removable media.
#    /media/KINGSTON/.otpr
# Yang refers to the disk cache.
#   ~/.cache/otpr
# The yin/yang salts are:

   # Looks like 10000010101101100111...
   s0 = E[256]
   s1 = E[256]

# These have 256 bits of entropy.
# That's a lot of bits.  Let's use hexadecimal notation.
# Coverting to and from hexadecimal is "easy".
# That is, it's a reversible process.
# To show that in notation, let's use the * operator.

  module Convertible
    def *(n)
      entropy = Entropy.new(self.to_i(base).to_s(n), n)
      entropy.set_bits(self.bits)
      return entropy
    end
  end
  Entropy.include Convertible

# Hexadecimal notation is madeup of 16 symbols.

  H = 16

# So to refer to the hex represention of s0 and s1, do:
 
  # Looks like b338f69415...
  s0*H
  s1*H

# Just to show that this is reversible:

  # Looks like 1000001...
  (s0*H)*2
  (s0*H)*2 == s0 #=> true

# The above looks strange for `*`, but
# later it will make more sense.
# In the libray, I use BaseConvert because
# it allows me to use arbitrary symbols
# and base size greater than 36.
# Let Q be a base 91 representation.
# Let W be a base 62 representation.

  Q = 91
  W = 62

# You'll get an "invalid radix 91" error
# if you try to convert to these bases with the simple code above
# because there's no standard way to represent these.
# As shown, we can go up to 36:

  # looks like 24e5iq2s...
  s0*36

# Just to show I ain't cheatin'...

  require 'base_convert'
  module Convertible
    def *(n)
      base = BaseConvert.new(self.base, n)
      # What is zero's symbol in this base?
      zero = base.to_digits.first
      entropy = Entropy.new(base.convert(self.to_s), n)
      entropy.set_bits(self.bits, zero)
      return entropy
    end
  end
  Entropy.include Convertible

  # looks like #RaRVL<Y...
  s0*Q
  s0*Q*2 == s0 #=>true

  # looks like KBk48Wqa...
  s0*W
  s0*W*2 == s0 #=> true

# s0*Q and s1*Q is what's stored in the salt files.
# This makes it easier to inspect.
# The combined salt is:

  s = s0*Q + s1*Q

# The passphrase is the salted pin, which is given by the user.
# I'll denote the pin as p, and the passphrase as w:

  p = 'abc' # whatever the user says
  w = s + p
  # or expanded out...
  w = s0*Q + s1*Q + p

# BTW, + and * behave as expected for the righ choice of base(2**n), but 
# I need to overwrite the + operator to stay in the class:

  class Entropy
    def +(e)
      Entropy.new(super)
    end
  end

  a = s0*H + s1*H
  b = (s0 + s1)*H
  # Works for H
  a == b
  # => true

  a = s0*Q + s1*Q
  b = (s0 + s1)*Q
  # Doesn't work for Q
  a == b
  # => false

# I'm going to do some log fun next, so for concision:

  module Ln
    def self.[](n)
      Math.log(n)
    end
  end

# According to Wikipedia's
# *Paswords strength[http://en.wikipedia.org/wiki/Password_strength]*
# article:
#   Due to currently understood limitations from fundamental physics,
#   there is no expectation that any digital computer (or combination)
#   will be capable of breaking 256-bit encryption via a brute-force attack.
# Let's look at this claim with some quick numbers:
#   Planck time[http://en.wikipedia.org/wiki/Planck_time] :: ~ 5.4eâˆ’44 seconds
    plank_time = 5.4e-44 # seconds
    total_time = plank_time * (2**256) # ~ 6.3e+33 seconds, that looks like long time!
    2.0**256.0 #=> ~ 1.2e+77
# Just curious, what's a 2 year's crack of this "planck" computer?
    total_time = 60*60*24*365*2
    bits = total_time / plank_time #=> 1.168e+51
    (Ln[bits]/Ln[2]).round #=> ~ 170
# So it would crack a 170 bit password in just over a year.
    Ln[2]*170/Ln[256] #=> ~ 21.2
    Ln[2]*170/Ln[91]  #=> ~ 26.1 (Q passwords length)
    Ln[2]*170/Ln[62]  #=> ~ 28.6 (W passwords length)
# I'll just keep 256 bits of entropy.
# For this purpose I'll use SHA256.
# I'll also be using MD5.

  require 'digest'
  D = Digest::SHA256
  C = Digest::MD5

# For concise notation, recognize that digest are thought of hashes:

  module HashNotation
    def [](key)
      self.digest(key)
    end
  end
  C.extend HashNotation
  D.extend HashNotation

  d0 = D[w]
  d0.length
  # => 32

# The digest of w is a binary string of length 32.
# This equivalent to 256 bits of entropy.

  2**256 == 256**32 # => true

# Expanded out, d0 is:

  d0 = D[ s0*Q + s1*Q + p ]

# I need a key to encript the secret.
# Encription will be a simple xor, which
# is fine for a secret about the size of the key.
# Because passwords typically can't use the full 256 ascii set,
# a graph password would have to be at least 40 characters long
# to contain about 256 bits of entropy, which is longer than d0.
# According to the Password strength article in Wikipedia,
# a *Case sensitive Latin alphabet* password would need to be 45 characters long.
# I just need a key a little bigger that d.  So I add MD5.

  d1 = C[w]
  k0  = d0 + d1
  k0.length == 48
  # => true

# Now my key, k0, has more than 256 bits of entropy, but that's OK.
# So the key, k0, expanded out is:

  k0 = D[s0*Q + s1*Q + p] + C[s0*Q + s1*Q + p]
  k0.length == 48
  # => true

# Given our plain text secret, s:

  s = 'Top Secret Password!'

# We want to *xor* with the key:

  module Xor
    def ^(secret, i=-1)
      secret.bytes.inject(''){|plain, byte| plain+(byte^self.bytes[(i+=1)%length]).chr}
    end
  end
  k0.extend Xor

# Now we can encript the secret:

  c = k0^s  # => looks like S{)\xABI\x02...
  k0^c      # => 'Top Secret Password!'
  s == k0^c # => true!

# Tada!
# It be nice to have the digest auto extend the xor, and
# retain the method under addition...
# and know how to handle * too!

  module Operators
    def +(x)
      x = super
      x.extend Xor
      return x
    end
    def *(x)
      e = self.bytes.inject(''){|e, byte| e<<byte.to_s(16)}
      e = Entropy.new(e, 16)
      return e*x
    end
  end

  class D
    def digest(s)
      dg = super
      dg.extend Xor
      dg.extend Operators
      return dg
    end
  end

  class C
    def digest(s)
      dg = super
      dg.extend Xor
      dg.extend Operators
      return dg
    end
  end

  d0 = D[w]
  d1 = C[w]

# Now I should be able to expand it all out:

   c = (D[s0*Q + s1*Q + p] + C[s0*Q + s1*Q + p])^s

   (D[s0*Q + s1*Q + p] + C[s0*Q + s1*Q + p])^c
   #=> "Top Secret Password!"

   s == (D[s0*Q + s1*Q + p] + C[s0*Q + s1*Q + p])^c
   # => true

# To store the encripted secret, and allow the use of multiple pins,
# I need a filename, f, that's based on the pin, but
# that cannot be reversed back to the pin.

   # Looks like 1Rpq3qgBnMMLC3aPUsS7t
   f = d1*W
   # or expanded out...
   f = C[s0*Q + s1*Q + p]*W
   # You can verify that
   d1*W == C[s0*Q + s1*Q + p]*W #=> true

# I save the secret in the cache directory under the name of f.
# But what if at some point, because the salts and pin don't change,
# the passphrase to the secret is compromised?
# The p(pin) is in your head, s0(Yin's salt) is in removable media, and
# s1(Yang's salt) is in a user only readable directory.
# How is the passphrase going to be compromised?  LOL.
# But let's make it as near impossible as possible!  :P
# I re-encript with a new random key and save the key in the removable media under f.

  q = E[256]*Q
  k1 = D[q]+C[q]

# BTW, here k1 has 256 bits of entropy, not more.

  c1 = k1^c0

# q is saved in yin/f and c1 is saved in yang/f.
# The --regen option allows one to re-generate the two files.
# The regenaration does not need to know the passphrase.
# So if at anytime any either Yin or Yang is compromised,
# just regenarate all the pads.
