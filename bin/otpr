#!/usr/bin/env ruby

# Gems
require 'rainbow'
require 'help_parser'
require 'user_space'

# This Gem
require 'otpr'
include OTPR

# This is an undocumented flag.
# If the very first argument is a -t,
# we're running in test mode.
if ARGV[0]=='-t'
  ARGV.shift
  T = true
else
  T = false
end

def error_message
  msg = $!.message
  msg = (CONFIG[msg.to_sym] || msg).color(:red) unless T
  STDERR.puts msg
end

def assert(b, comment)
  unless b # This is a sanity check.
    STDERR.puts (CONFIG[comment] || comment).color(:red)
    exit 76 # ProtocolError: This error really should not be possible.
  end
end

def assert_equal(a, b, comment)
  assert(a==b, comment)
end

def ask(question)
  print question
  STDIN.gets.strip
end

def system_clear
  system(CONFIG[:clear_command]) if CONFIG[:clear]
end

def get_pin
  pin = (CONFIG[:batch])? STDIN.gets.strip : Pin.gets
  system_clear
  return pin
end

def user_secret
  secret = nil
  if CONFIG[:batch]
    secret = STDIN.gets.strip
  else
    options = {
      :enter_pin      => CONFIG[:enter_secret],
      :pin_validation => CONFIG[:secret_validation],
      :pin_min        => CONFIG[:secret_min],
      :pin_too_short  => CONFIG[:secret_too_short],
      :pin_max        => CONFIG[:secret_max],
      :pin_too_long   => CONFIG[:secret_too_long],
      :pin_accept     => CONFIG[:secret_accept],
      :pin_reject     => CONFIG[:secret_reject],
      :pin_not_valid  => CONFIG[:secret_not_valid],
      :repeat_pin     => CONFIG[:repeat_secret],
    }
    secret = Pin.gets(options)
  end
  system_clear
  return secret
end

def computer_random
  return Entropy.computer.to(:qgraph) if CONFIG[:batch]
  random = Entropy.redundant.to(:qgraph)
  system_clear
  return random
end

def get_secret
  (CONFIG[:random])? computer_random : user_secret
end

def get_salt(dir)
  saltfile = File.join dir, 'salt'
  unless File.exist? saltfile
    STDERR.puts (CONFIG[:writting] + saltfile).color(:green)
    File.open(saltfile, 'w', 0600){|f| f.write Entropy.computer.to(:qgraph)}
  end
  File.read saltfile
end

def delete_files_in_dir(dir)
  Dir.glob(File.join(dir, '*')).each do |filename|
    # Don't know why there would be anything but regular file, but...
    if File.file?(filename)
      File.unlink(filename)
    else
      STDERR.puts "Did not delete #{filename}".color(:green)
    end
  end
end

USERSPACE = USER_SPACE::UserSpace.new
USERSPACE.trace = STDERR
USERSPACE.configures(CONFIG)

begin
  OPTIONS = HELP_PARSER::HelpParser.new(VERSION, CONFIG[:help])
  unless [:c,:r,:u,:d,:s,:C,:M,:erase].inject(false){|b,k| b^OPTIONS[k]}
    OPTIONS.usage_error(:choose_one) 
  end
  CONFIG.keys.each do |key|
    CONFIG[key] = OPTIONS[key] unless OPTIONS[key].nil?
  end

  raise OTPR::Error, :media_not_found unless File.exist? CONFIG[:media]
  MEDIA_CACHE = File.join CONFIG[:media], '.otpr'
  Dir.mkdir(MEDIA_CACHE, 0700) unless File.exist? MEDIA_CACHE
  assert File.directory?(MEDIA_CACHE), "Not a directory:#{MEDIA_CACHE}"

  SALT = get_salt(MEDIA_CACHE) + get_salt(USERSPACE.cachedir)

  if OPTIONS[:erase]
    if ask(CONFIG[:confirm_erase])==CONFIG[:y]
      delete_files_in_dir(MEDIA_CACHE)
      delete_files_in_dir(USERSPACE.cachedir)
      puts CONFIG[:ok]
    else
      puts CONFIG[:cancelled]
    end
    exit
  end

  otpr = Otpr.new(SALT+get_pin, MEDIA_CACHE, USERSPACE.cachedir)

  if OPTIONS[:create]
    OPTIONS.usage_error(:pin_exist) if otpr.exist?
    secret = get_secret
    otpr.set secret
    assert_equal(otpr.get, secret, :could_not_set)
    puts secret
    exit
  end

  if OPTIONS[:update]
    OPTIONS.usage_error(:pin_does_not_exist) unless otpr.exist?
    puts otpr.get unless CONFIG[:batch]
    secret = get_secret
    otpr.set secret
    assert_equal(otpr.get, secret, :could_not_set)
    puts secret
    exit
  end

  if OPTIONS[:copy] or OPTIONS[:move]
    OPTIONS.usage_error(:pin_does_not_exist) unless otpr.exist?
    otpr2 = Otpr.new(SALT+get_pin, USERSPACE.cachedir, MEDIA_CACHE)
    OPTIONS.usage_error(:pin_exists) unless CONFIG[:overwrite] or !otpr2.exist?
    secret = otpr.get
    otpr2.set secret
    assert_equal(otpr2.get, secret, :could_not_set)
    otpr.delete if OPTIONS[:move]
    puts secret
    exit
  end

  if OPTIONS[:delete]
    OPTIONS.usage_error(:pin_does_not_exist) unless otpr.exist?
    confirmed = true
    unless CONFIG[:batch]
      puts otpr.get
      confirmed = ask(CONFIG[:confirm_delete])==CONFIG[:y]
    end
    if confirmed
      otpr.delete
      puts CONFIG[:ok]
    else
      puts CONFIG[:cancelled]
    end
    exit
  end

  if OPTIONS[:read]
    OPTIONS.usage_error(:pin_does_not_exist) unless otpr.exist?
    secret = otpr.get
    puts secret
    if CONFIG[:regen]
      otpr.set secret
      assert_equal(otpr.get, secret, :could_not_set)
    end
    exit
  end

  if OPTIONS[:status]
    if otpr.exist?
      puts CONFIG[:ok]
      exit 0
    elsif otpr.inconsistent?
      puts CONFIG[:inconsistent]
      exit 76 # Protocol error, should not be possible.
    else
      puts CONFIG[:not_found]
      exit 66 # No Input error code
    end
  end

  assert(false, :unexpected_program_flow)

rescue OTPR::Error
  error_message
  # Most likely a user fixable failure.
  # Maybe the user forgot to insert the media.
  # So categorized here as a TempFail.
  exit 75
rescue HELP_PARSER::UsageException
  puts $!.message
  exit 0
rescue HELP_PARSER::UsageError
  error_message
  exit 64
end
